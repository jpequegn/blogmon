# Phase 1 MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a working blog reader CLI with init, add, fetch, list, show commands.

**Architecture:** Cobra CLI framework with SQLite storage. Pipeline pattern where each command operates on the database. RSS/Atom parsing via gofeed library.

**Tech Stack:** Go 1.21+, Cobra (CLI), SQLite3, gofeed (RSS), lipgloss (terminal styling)

---

## Task 1: Project Initialization

**Files:**
- Create: `go.mod`
- Create: `main.go`
- Create: `cmd/root.go`

**Step 1: Initialize Go module**

Run:
```bash
cd /Users/julienpequegnot/Code/blogmon
go mod init github.com/julienpequegnot/blogmon
```

Expected: `go.mod` file created

**Step 2: Install dependencies**

Run:
```bash
go get github.com/spf13/cobra@latest
go get github.com/mattn/go-sqlite3
go get github.com/mmcdole/gofeed
go get github.com/charmbracelet/lipgloss
```

Expected: Dependencies added to `go.mod`

**Step 3: Create main.go**

```go
// main.go
package main

import "github.com/julienpequegnot/blogmon/cmd"

func main() {
	cmd.Execute()
}
```

**Step 4: Create root command**

```go
// cmd/root.go
package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
	Use:   "blogmon",
	Short: "Monitor developer blogs and build a knowledge base",
	Long:  `Blogmon fetches posts from developer blogs, extracts insights, scores content value, and builds a searchable knowledge base.`,
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
```

**Step 5: Verify it compiles**

Run:
```bash
go build -o blogmon .
./blogmon --help
```

Expected: Help message displays

**Step 6: Commit**

```bash
git add .
git commit -m "feat: initialize Go project with Cobra CLI"
```

---

## Task 2: Database Package

**Files:**
- Create: `internal/database/database.go`
- Create: `internal/database/database_test.go`

**Step 1: Write test for database initialization**

```go
// internal/database/database_test.go
package database

import (
	"os"
	"path/filepath"
	"testing"
)

func TestNewDB(t *testing.T) {
	tmpDir := t.TempDir()
	dbPath := filepath.Join(tmpDir, "test.db")

	db, err := New(dbPath)
	if err != nil {
		t.Fatalf("failed to create database: %v", err)
	}
	defer db.Close()

	if _, err := os.Stat(dbPath); os.IsNotExist(err) {
		t.Error("database file was not created")
	}
}

func TestInitSchema(t *testing.T) {
	tmpDir := t.TempDir()
	dbPath := filepath.Join(tmpDir, "test.db")

	db, err := New(dbPath)
	if err != nil {
		t.Fatalf("failed to create database: %v", err)
	}
	defer db.Close()

	// Verify tables exist by querying them
	tables := []string{"sources", "posts", "insights", "refs", "scores", "links", "interests"}
	for _, table := range tables {
		_, err := db.conn.Query("SELECT 1 FROM " + table + " LIMIT 1")
		if err != nil {
			t.Errorf("table %s does not exist: %v", table, err)
		}
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./internal/database/... -v
```

Expected: FAIL - package doesn't exist

**Step 3: Create database package**

```go
// internal/database/database.go
package database

import (
	"database/sql"
	"fmt"

	_ "github.com/mattn/go-sqlite3"
)

type DB struct {
	conn *sql.DB
	path string
}

func New(path string) (*DB, error) {
	conn, err := sql.Open("sqlite3", path+"?_foreign_keys=on")
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	db := &DB{conn: conn, path: path}
	if err := db.initSchema(); err != nil {
		conn.Close()
		return nil, fmt.Errorf("failed to initialize schema: %w", err)
	}

	return db, nil
}

func (db *DB) Close() error {
	return db.conn.Close()
}

func (db *DB) initSchema() error {
	schema := `
	CREATE TABLE IF NOT EXISTS sources (
		id INTEGER PRIMARY KEY,
		url TEXT NOT NULL UNIQUE,
		name TEXT,
		feed_url TEXT,
		discovered_from INTEGER REFERENCES posts(id),
		last_fetched DATETIME,
		active BOOLEAN DEFAULT TRUE,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP
	);

	CREATE TABLE IF NOT EXISTS posts (
		id INTEGER PRIMARY KEY,
		source_id INTEGER NOT NULL REFERENCES sources(id),
		url TEXT NOT NULL UNIQUE,
		title TEXT NOT NULL,
		author TEXT,
		published_at DATETIME,
		fetched_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		content_raw TEXT,
		content_clean TEXT,
		word_count INTEGER
	);

	CREATE TABLE IF NOT EXISTS insights (
		id INTEGER PRIMARY KEY,
		post_id INTEGER NOT NULL REFERENCES posts(id),
		type TEXT NOT NULL,
		content TEXT NOT NULL,
		importance INTEGER
	);

	CREATE TABLE IF NOT EXISTS refs (
		id INTEGER PRIMARY KEY,
		post_id INTEGER NOT NULL REFERENCES posts(id),
		url TEXT NOT NULL,
		title TEXT,
		context TEXT,
		is_blog BOOLEAN DEFAULT FALSE
	);

	CREATE TABLE IF NOT EXISTS scores (
		post_id INTEGER PRIMARY KEY REFERENCES posts(id),
		community_score REAL,
		relevance_score REAL,
		novelty_score REAL,
		final_score REAL,
		scored_at DATETIME DEFAULT CURRENT_TIMESTAMP
	);

	CREATE TABLE IF NOT EXISTS links (
		id INTEGER PRIMARY KEY,
		post_id_a INTEGER NOT NULL REFERENCES posts(id),
		post_id_b INTEGER NOT NULL REFERENCES posts(id),
		relationship TEXT NOT NULL,
		strength REAL,
		UNIQUE(post_id_a, post_id_b, relationship)
	);

	CREATE TABLE IF NOT EXISTS interests (
		id INTEGER PRIMARY KEY,
		topic TEXT NOT NULL UNIQUE,
		weight REAL DEFAULT 1.0,
		keywords TEXT
	);

	CREATE INDEX IF NOT EXISTS idx_posts_source ON posts(source_id);
	CREATE INDEX IF NOT EXISTS idx_posts_published ON posts(published_at);
	CREATE INDEX IF NOT EXISTS idx_scores_final ON scores(final_score DESC);
	`

	_, err := db.conn.Exec(schema)
	return err
}
```

**Step 4: Run tests**

Run:
```bash
go test ./internal/database/... -v
```

Expected: PASS

**Step 5: Commit**

```bash
git add .
git commit -m "feat: add database package with SQLite schema"
```

---

## Task 3: Config Package

**Files:**
- Create: `internal/config/config.go`
- Create: `internal/config/config_test.go`

**Step 1: Write test for config**

```go
// internal/config/config_test.go
package config

import (
	"os"
	"path/filepath"
	"testing"
)

func TestDefaultConfig(t *testing.T) {
	cfg := Default()

	if cfg.Fetch.Concurrency != 5 {
		t.Errorf("expected concurrency 5, got %d", cfg.Fetch.Concurrency)
	}
	if cfg.Fetch.TimeoutSeconds != 30 {
		t.Errorf("expected timeout 30, got %d", cfg.Fetch.TimeoutSeconds)
	}
}

func TestConfigDir(t *testing.T) {
	tmpDir := t.TempDir()
	os.Setenv("BLOGMON_HOME", tmpDir)
	defer os.Unsetenv("BLOGMON_HOME")

	dir := Dir()
	if dir != tmpDir {
		t.Errorf("expected %s, got %s", tmpDir, dir)
	}
}

func TestSaveAndLoad(t *testing.T) {
	tmpDir := t.TempDir()
	os.Setenv("BLOGMON_HOME", tmpDir)
	defer os.Unsetenv("BLOGMON_HOME")

	cfg := Default()
	cfg.Fetch.Concurrency = 10

	if err := Save(cfg); err != nil {
		t.Fatalf("failed to save config: %v", err)
	}

	loaded, err := Load()
	if err != nil {
		t.Fatalf("failed to load config: %v", err)
	}

	if loaded.Fetch.Concurrency != 10 {
		t.Errorf("expected concurrency 10, got %d", loaded.Fetch.Concurrency)
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./internal/config/... -v
```

Expected: FAIL

**Step 3: Implement config package**

```go
// internal/config/config.go
package config

import (
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

type Config struct {
	Interests []Interest    `yaml:"interests"`
	Scoring   ScoringConfig `yaml:"scoring"`
	APIs      APIConfig     `yaml:"apis"`
	Fetch     FetchConfig   `yaml:"fetch"`
	Daemon    DaemonConfig  `yaml:"daemon"`
	Reddit    RedditConfig  `yaml:"reddit"`
}

type Interest struct {
	Topic    string   `yaml:"topic"`
	Weight   float64  `yaml:"weight"`
	Keywords []string `yaml:"keywords,omitempty"`
}

type ScoringConfig struct {
	Community float64 `yaml:"community"`
	Relevance float64 `yaml:"relevance"`
	Novelty   float64 `yaml:"novelty"`
}

type APIConfig struct {
	LLMProvider string `yaml:"llm_provider"`
	LLMModel    string `yaml:"llm_model"`
	OpenAIKey   string `yaml:"openai_key,omitempty"`
}

type FetchConfig struct {
	Concurrency    int    `yaml:"concurrency"`
	TimeoutSeconds int    `yaml:"timeout_seconds"`
	UserAgent      string `yaml:"user_agent"`
}

type DaemonConfig struct {
	IntervalHours int `yaml:"interval_hours"`
}

type RedditConfig struct {
	Subreddits []string `yaml:"subreddits"`
}

func Default() *Config {
	return &Config{
		Interests: []Interest{},
		Scoring: ScoringConfig{
			Community: 0.3,
			Relevance: 0.4,
			Novelty:   0.3,
		},
		APIs: APIConfig{
			LLMProvider: "ollama",
			LLMModel:    "llama3.2",
		},
		Fetch: FetchConfig{
			Concurrency:    5,
			TimeoutSeconds: 30,
			UserAgent:      "blogmon/1.0",
		},
		Daemon: DaemonConfig{
			IntervalHours: 6,
		},
		Reddit: RedditConfig{
			Subreddits: []string{"programming", "golang"},
		},
	}
}

func Dir() string {
	if dir := os.Getenv("BLOGMON_HOME"); dir != "" {
		return dir
	}
	home, _ := os.UserHomeDir()
	return filepath.Join(home, ".blogmon")
}

func DBPath() string {
	return filepath.Join(Dir(), "blogmon.db")
}

func configPath() string {
	return filepath.Join(Dir(), "config.yaml")
}

func Load() (*Config, error) {
	data, err := os.ReadFile(configPath())
	if err != nil {
		if os.IsNotExist(err) {
			return Default(), nil
		}
		return nil, err
	}

	cfg := Default()
	if err := yaml.Unmarshal(data, cfg); err != nil {
		return nil, err
	}
	return cfg, nil
}

func Save(cfg *Config) error {
	if err := os.MkdirAll(Dir(), 0755); err != nil {
		return err
	}

	data, err := yaml.Marshal(cfg)
	if err != nil {
		return err
	}

	return os.WriteFile(configPath(), data, 0644)
}
```

**Step 4: Add yaml dependency and run tests**

Run:
```bash
go get gopkg.in/yaml.v3
go test ./internal/config/... -v
```

Expected: PASS

**Step 5: Commit**

```bash
git add .
git commit -m "feat: add config package with YAML support"
```

---

## Task 4: Init Command

**Files:**
- Create: `cmd/init.go`
- Create: `cmd/init_test.go`

**Step 1: Write test for init command**

```go
// cmd/init_test.go
package cmd

import (
	"os"
	"path/filepath"
	"testing"
)

func TestInitCommand(t *testing.T) {
	tmpDir := t.TempDir()
	os.Setenv("BLOGMON_HOME", tmpDir)
	defer os.Unsetenv("BLOGMON_HOME")

	// Execute init command
	rootCmd.SetArgs([]string{"init"})
	if err := rootCmd.Execute(); err != nil {
		t.Fatalf("init command failed: %v", err)
	}

	// Check config.yaml exists
	configPath := filepath.Join(tmpDir, "config.yaml")
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		t.Error("config.yaml was not created")
	}

	// Check database exists
	dbPath := filepath.Join(tmpDir, "blogmon.db")
	if _, err := os.Stat(dbPath); os.IsNotExist(err) {
		t.Error("blogmon.db was not created")
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./cmd/... -v -run TestInitCommand
```

Expected: FAIL - init command not found

**Step 3: Implement init command**

```go
// cmd/init.go
package cmd

import (
	"fmt"
	"os"

	"github.com/julienpequegnot/blogmon/internal/config"
	"github.com/julienpequegnot/blogmon/internal/database"
	"github.com/spf13/cobra"
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize blogmon configuration and database",
	Long:  `Creates the ~/.blogmon directory with config.yaml and SQLite database.`,
	RunE:  runInit,
}

func init() {
	rootCmd.AddCommand(initCmd)
}

func runInit(cmd *cobra.Command, args []string) error {
	dir := config.Dir()

	// Create directory
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Create config
	cfg := config.Default()
	if err := config.Save(cfg); err != nil {
		return fmt.Errorf("failed to save config: %w", err)
	}
	fmt.Printf("Created config at %s/config.yaml\n", dir)

	// Create database
	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to create database: %w", err)
	}
	db.Close()
	fmt.Printf("Created database at %s/blogmon.db\n", dir)

	fmt.Println("\nBlogmon initialized! Next steps:")
	fmt.Println("  blogmon add <blog-url>    Add a blog to monitor")
	fmt.Println("  blogmon fetch             Fetch posts from all blogs")

	return nil
}
```

**Step 4: Run tests**

Run:
```bash
go test ./cmd/... -v -run TestInitCommand
```

Expected: PASS

**Step 5: Manual test**

Run:
```bash
go build -o blogmon . && ./blogmon init
```

Expected: Shows initialization messages

**Step 6: Commit**

```bash
git add .
git commit -m "feat: add init command"
```

---

## Task 5: Source Repository

**Files:**
- Create: `internal/source/repository.go`
- Create: `internal/source/repository_test.go`

**Step 1: Write repository tests**

```go
// internal/source/repository_test.go
package source

import (
	"path/filepath"
	"testing"

	"github.com/julienpequegnot/blogmon/internal/database"
)

func setupTestDB(t *testing.T) *database.DB {
	tmpDir := t.TempDir()
	db, err := database.New(filepath.Join(tmpDir, "test.db"))
	if err != nil {
		t.Fatalf("failed to create test database: %v", err)
	}
	return db
}

func TestAddSource(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := NewRepository(db)

	src, err := repo.Add("https://jvns.ca", "Julia Evans", "https://jvns.ca/atom.xml")
	if err != nil {
		t.Fatalf("failed to add source: %v", err)
	}

	if src.ID == 0 {
		t.Error("expected non-zero ID")
	}
	if src.URL != "https://jvns.ca" {
		t.Errorf("expected URL https://jvns.ca, got %s", src.URL)
	}
}

func TestAddDuplicateSource(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := NewRepository(db)

	_, err := repo.Add("https://jvns.ca", "Julia Evans", "")
	if err != nil {
		t.Fatalf("failed to add source: %v", err)
	}

	_, err = repo.Add("https://jvns.ca", "Julia Evans", "")
	if err == nil {
		t.Error("expected error for duplicate source")
	}
}

func TestListSources(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()

	repo := NewRepository(db)

	repo.Add("https://jvns.ca", "Julia Evans", "")
	repo.Add("https://fasterthanli.me", "fasterthanlime", "")

	sources, err := repo.List()
	if err != nil {
		t.Fatalf("failed to list sources: %v", err)
	}

	if len(sources) != 2 {
		t.Errorf("expected 2 sources, got %d", len(sources))
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./internal/source/... -v
```

Expected: FAIL

**Step 3: Implement repository**

```go
// internal/source/repository.go
package source

import (
	"fmt"
	"time"

	"github.com/julienpequegnot/blogmon/internal/database"
)

type Source struct {
	ID            int64
	URL           string
	Name          string
	FeedURL       string
	DiscoveredFrom *int64
	LastFetched   *time.Time
	Active        bool
	CreatedAt     time.Time
}

type Repository struct {
	db *database.DB
}

func NewRepository(db *database.DB) *Repository {
	return &Repository{db: db}
}

func (r *Repository) Add(url, name, feedURL string) (*Source, error) {
	result, err := r.db.Exec(
		`INSERT INTO sources (url, name, feed_url, active) VALUES (?, ?, ?, TRUE)`,
		url, name, feedURL,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to insert source: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, err
	}

	return &Source{
		ID:      id,
		URL:     url,
		Name:    name,
		FeedURL: feedURL,
		Active:  true,
	}, nil
}

func (r *Repository) List() ([]Source, error) {
	rows, err := r.db.Query(`SELECT id, url, name, feed_url, last_fetched, active, created_at FROM sources WHERE active = TRUE ORDER BY name`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var sources []Source
	for rows.Next() {
		var s Source
		if err := rows.Scan(&s.ID, &s.URL, &s.Name, &s.FeedURL, &s.LastFetched, &s.Active, &s.CreatedAt); err != nil {
			return nil, err
		}
		sources = append(sources, s)
	}
	return sources, rows.Err()
}

func (r *Repository) UpdateLastFetched(id int64) error {
	_, err := r.db.Exec(`UPDATE sources SET last_fetched = CURRENT_TIMESTAMP WHERE id = ?`, id)
	return err
}
```

**Step 4: Add Exec and Query methods to database**

```go
// Add to internal/database/database.go

func (db *DB) Exec(query string, args ...any) (sql.Result, error) {
	return db.conn.Exec(query, args...)
}

func (db *DB) Query(query string, args ...any) (*sql.Rows, error) {
	return db.conn.Query(query, args...)
}

func (db *DB) QueryRow(query string, args ...any) *sql.Row {
	return db.conn.QueryRow(query, args...)
}
```

**Step 5: Run tests**

Run:
```bash
go test ./internal/source/... -v
```

Expected: PASS

**Step 6: Commit**

```bash
git add .
git commit -m "feat: add source repository"
```

---

## Task 6: Add Command

**Files:**
- Create: `cmd/add.go`
- Create: `internal/feed/discover.go`

**Step 1: Create feed discovery for RSS auto-detection**

```go
// internal/feed/discover.go
package feed

import (
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strings"
	"time"
)

var feedPatterns = []string{
	"/feed",
	"/feed.xml",
	"/atom.xml",
	"/rss.xml",
	"/rss",
	"/index.xml",
	"/feed/atom",
	"/feed/rss",
}

var linkRegex = regexp.MustCompile(`<link[^>]+type=["'](application/(rss|atom)\+xml)["'][^>]*href=["']([^"']+)["']`)

func DiscoverFeed(siteURL string) (string, error) {
	client := &http.Client{Timeout: 10 * time.Second}

	// Try to find feed link in HTML
	resp, err := client.Get(siteURL)
	if err == nil {
		defer resp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 100000))
		matches := linkRegex.FindStringSubmatch(string(body))
		if len(matches) > 3 {
			feedURL := matches[3]
			if !strings.HasPrefix(feedURL, "http") {
				feedURL = strings.TrimSuffix(siteURL, "/") + "/" + strings.TrimPrefix(feedURL, "/")
			}
			return feedURL, nil
		}
	}

	// Try common feed paths
	baseURL := strings.TrimSuffix(siteURL, "/")
	for _, pattern := range feedPatterns {
		feedURL := baseURL + pattern
		resp, err := client.Head(feedURL)
		if err == nil && resp.StatusCode == 200 {
			return feedURL, nil
		}
	}

	return "", fmt.Errorf("could not discover feed for %s", siteURL)
}
```

**Step 2: Create add command**

```go
// cmd/add.go
package cmd

import (
	"fmt"
	"net/url"
	"strings"

	"github.com/julienpequegnot/blogmon/internal/config"
	"github.com/julienpequegnot/blogmon/internal/database"
	"github.com/julienpequegnot/blogmon/internal/feed"
	"github.com/julienpequegnot/blogmon/internal/source"
	"github.com/spf13/cobra"
)

var addCmd = &cobra.Command{
	Use:   "add <url>",
	Short: "Add a blog or RSS feed to monitor",
	Long:  `Add a blog URL or RSS feed URL to the list of monitored sources.`,
	Args:  cobra.ExactArgs(1),
	RunE:  runAdd,
}

var addName string

func init() {
	rootCmd.AddCommand(addCmd)
	addCmd.Flags().StringVarP(&addName, "name", "n", "", "Custom name for the blog")
}

func runAdd(cmd *cobra.Command, args []string) error {
	siteURL := args[0]

	// Ensure URL has scheme
	if !strings.HasPrefix(siteURL, "http") {
		siteURL = "https://" + siteURL
	}

	// Parse URL to extract domain for name
	parsed, err := url.Parse(siteURL)
	if err != nil {
		return fmt.Errorf("invalid URL: %w", err)
	}

	name := addName
	if name == "" {
		name = parsed.Host
	}

	// Try to discover RSS feed
	fmt.Printf("Discovering feed for %s...\n", siteURL)
	feedURL, err := feed.DiscoverFeed(siteURL)
	if err != nil {
		fmt.Printf("Warning: %v\n", err)
		fmt.Println("Adding without feed URL - you may need to add it manually")
	} else {
		fmt.Printf("Found feed: %s\n", feedURL)
	}

	// Open database
	db, err := database.New(config.DBPath())
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	// Add source
	repo := source.NewRepository(db)
	src, err := repo.Add(siteURL, name, feedURL)
	if err != nil {
		if strings.Contains(err.Error(), "UNIQUE constraint") {
			return fmt.Errorf("source already exists: %s", siteURL)
		}
		return err
	}

	fmt.Printf("\nAdded: %s (ID: %d)\n", src.Name, src.ID)
	fmt.Println("\nRun 'blogmon fetch' to download posts")

	return nil
}
```

**Step 3: Build and test manually**

Run:
```bash
go build -o blogmon .
./blogmon init
./blogmon add https://jvns.ca
./blogmon add https://fasterthanli.me
```

Expected: Sources added with feed URLs discovered

**Step 4: Commit**

```bash
git add .
git commit -m "feat: add command with RSS feed discovery"
```

---

## Task 7: Post Repository

**Files:**
- Create: `internal/post/repository.go`
- Create: `internal/post/repository_test.go`

**Step 1: Write tests**

```go
// internal/post/repository_test.go
package post

import (
	"path/filepath"
	"testing"
	"time"

	"github.com/julienpequegnot/blogmon/internal/database"
	"github.com/julienpequegnot/blogmon/internal/source"
)

func setupTestDB(t *testing.T) (*database.DB, *source.Source) {
	tmpDir := t.TempDir()
	db, err := database.New(filepath.Join(tmpDir, "test.db"))
	if err != nil {
		t.Fatalf("failed to create test database: %v", err)
	}

	srcRepo := source.NewRepository(db)
	src, err := srcRepo.Add("https://test.com", "Test Blog", "https://test.com/feed")
	if err != nil {
		t.Fatalf("failed to add source: %v", err)
	}

	return db, src
}

func TestAddPost(t *testing.T) {
	db, src := setupTestDB(t)
	defer db.Close()

	repo := NewRepository(db)

	post, err := repo.Add(src.ID, "https://test.com/post1", "Test Post", "Author", time.Now(), "<p>Content</p>")
	if err != nil {
		t.Fatalf("failed to add post: %v", err)
	}

	if post.ID == 0 {
		t.Error("expected non-zero ID")
	}
}

func TestListPosts(t *testing.T) {
	db, src := setupTestDB(t)
	defer db.Close()

	repo := NewRepository(db)

	repo.Add(src.ID, "https://test.com/post1", "Post 1", "Author", time.Now(), "")
	repo.Add(src.ID, "https://test.com/post2", "Post 2", "Author", time.Now(), "")

	posts, err := repo.List(10, 0)
	if err != nil {
		t.Fatalf("failed to list posts: %v", err)
	}

	if len(posts) != 2 {
		t.Errorf("expected 2 posts, got %d", len(posts))
	}
}

func TestPostExists(t *testing.T) {
	db, src := setupTestDB(t)
	defer db.Close()

	repo := NewRepository(db)

	repo.Add(src.ID, "https://test.com/post1", "Post 1", "Author", time.Now(), "")

	exists, err := repo.Exists("https://test.com/post1")
	if err != nil {
		t.Fatalf("failed to check existence: %v", err)
	}
	if !exists {
		t.Error("expected post to exist")
	}

	exists, err = repo.Exists("https://test.com/nonexistent")
	if err != nil {
		t.Fatalf("failed to check existence: %v", err)
	}
	if exists {
		t.Error("expected post to not exist")
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./internal/post/... -v
```

Expected: FAIL

**Step 3: Implement repository**

```go
// internal/post/repository.go
package post

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/julienpequegnot/blogmon/internal/database"
)

type Post struct {
	ID           int64
	SourceID     int64
	SourceName   string
	URL          string
	Title        string
	Author       string
	PublishedAt  *time.Time
	FetchedAt    time.Time
	ContentRaw   string
	ContentClean string
	WordCount    int
	FinalScore   *float64
}

type Repository struct {
	db *database.DB
}

func NewRepository(db *database.DB) *Repository {
	return &Repository{db: db}
}

func (r *Repository) Add(sourceID int64, url, title, author string, publishedAt time.Time, contentRaw string) (*Post, error) {
	result, err := r.db.Exec(
		`INSERT INTO posts (source_id, url, title, author, published_at, content_raw) VALUES (?, ?, ?, ?, ?, ?)`,
		sourceID, url, title, author, publishedAt, contentRaw,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to insert post: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, err
	}

	return &Post{
		ID:          id,
		SourceID:    sourceID,
		URL:         url,
		Title:       title,
		Author:      author,
		PublishedAt: &publishedAt,
		ContentRaw:  contentRaw,
	}, nil
}

func (r *Repository) Exists(url string) (bool, error) {
	var count int
	err := r.db.QueryRow(`SELECT COUNT(*) FROM posts WHERE url = ?`, url).Scan(&count)
	return count > 0, err
}

func (r *Repository) List(limit, offset int) ([]Post, error) {
	rows, err := r.db.Query(`
		SELECT p.id, p.source_id, s.name, p.url, p.title, p.author, p.published_at, p.fetched_at,
		       COALESCE(sc.final_score, 0) as final_score
		FROM posts p
		JOIN sources s ON p.source_id = s.id
		LEFT JOIN scores sc ON p.id = sc.post_id
		ORDER BY p.published_at DESC
		LIMIT ? OFFSET ?
	`, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var posts []Post
	for rows.Next() {
		var p Post
		var score sql.NullFloat64
		if err := rows.Scan(&p.ID, &p.SourceID, &p.SourceName, &p.URL, &p.Title, &p.Author, &p.PublishedAt, &p.FetchedAt, &score); err != nil {
			return nil, err
		}
		if score.Valid {
			p.FinalScore = &score.Float64
		}
		posts = append(posts, p)
	}
	return posts, rows.Err()
}

func (r *Repository) Get(id int64) (*Post, error) {
	var p Post
	var score sql.NullFloat64
	err := r.db.QueryRow(`
		SELECT p.id, p.source_id, s.name, p.url, p.title, p.author, p.published_at, p.fetched_at,
		       p.content_raw, p.content_clean, COALESCE(p.word_count, 0),
		       COALESCE(sc.final_score, 0)
		FROM posts p
		JOIN sources s ON p.source_id = s.id
		LEFT JOIN scores sc ON p.id = sc.post_id
		WHERE p.id = ?
	`, id).Scan(&p.ID, &p.SourceID, &p.SourceName, &p.URL, &p.Title, &p.Author, &p.PublishedAt, &p.FetchedAt,
		&p.ContentRaw, &p.ContentClean, &p.WordCount, &score)
	if err != nil {
		return nil, err
	}
	if score.Valid {
		p.FinalScore = &score.Float64
	}
	return &p, nil
}
```

**Step 4: Run tests**

Run:
```bash
go test ./internal/post/... -v
```

Expected: PASS

**Step 5: Commit**

```bash
git add .
git commit -m "feat: add post repository"
```

---

## Task 8: Fetch Command

**Files:**
- Create: `internal/feed/fetcher.go`
- Create: `cmd/fetch.go`

**Step 1: Create feed fetcher**

```go
// internal/feed/fetcher.go
package feed

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/mmcdole/gofeed"
)

type FetchedPost struct {
	URL         string
	Title       string
	Author      string
	PublishedAt time.Time
	Content     string
}

type Fetcher struct {
	parser  *gofeed.Parser
	client  *http.Client
	timeout time.Duration
}

func NewFetcher(timeout time.Duration) *Fetcher {
	return &Fetcher{
		parser: gofeed.NewParser(),
		client: &http.Client{Timeout: timeout},
	}
}

func (f *Fetcher) FetchFeed(feedURL string) ([]FetchedPost, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	feed, err := f.parser.ParseURLWithContext(feedURL, ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to parse feed: %w", err)
	}

	var posts []FetchedPost
	for _, item := range feed.Items {
		post := FetchedPost{
			URL:   item.Link,
			Title: item.Title,
		}

		if item.Author != nil {
			post.Author = item.Author.Name
		} else if len(feed.Authors) > 0 {
			post.Author = feed.Authors[0].Name
		}

		if item.PublishedParsed != nil {
			post.PublishedAt = *item.PublishedParsed
		} else if item.UpdatedParsed != nil {
			post.PublishedAt = *item.UpdatedParsed
		} else {
			post.PublishedAt = time.Now()
		}

		// Use content or description
		if item.Content != "" {
			post.Content = item.Content
		} else {
			post.Content = item.Description
		}

		posts = append(posts, post)
	}

	return posts, nil
}

func (f *Fetcher) FetchFullContent(postURL string) (string, error) {
	resp, err := f.client.Get(postURL)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("HTTP %d", resp.StatusCode)
	}

	body, err := io.ReadAll(io.LimitReader(resp.Body, 5*1024*1024)) // 5MB limit
	if err != nil {
		return "", err
	}

	return string(body), nil
}
```

**Step 2: Create fetch command**

```go
// cmd/fetch.go
package cmd

import (
	"fmt"
	"sync"
	"time"

	"github.com/julienpequegnot/blogmon/internal/config"
	"github.com/julienpequegnot/blogmon/internal/database"
	"github.com/julienpequegnot/blogmon/internal/feed"
	"github.com/julienpequegnot/blogmon/internal/post"
	"github.com/julienpequegnot/blogmon/internal/source"
	"github.com/spf13/cobra"
)

var fetchCmd = &cobra.Command{
	Use:   "fetch",
	Short: "Fetch new posts from all monitored blogs",
	Long:  `Downloads new posts from RSS feeds of all active sources.`,
	RunE:  runFetch,
}

var fetchConcurrency int

func init() {
	rootCmd.AddCommand(fetchCmd)
	fetchCmd.Flags().IntVarP(&fetchConcurrency, "concurrency", "c", 5, "Number of concurrent fetches")
}

func runFetch(cmd *cobra.Command, args []string) error {
	cfg, err := config.Load()
	if err != nil {
		return err
	}

	db, err := database.New(config.DBPath())
	if err != nil {
		return err
	}
	defer db.Close()

	srcRepo := source.NewRepository(db)
	postRepo := post.NewRepository(db)

	sources, err := srcRepo.List()
	if err != nil {
		return err
	}

	if len(sources) == 0 {
		fmt.Println("No sources configured. Add some with 'blogmon add <url>'")
		return nil
	}

	fetcher := feed.NewFetcher(time.Duration(cfg.Fetch.TimeoutSeconds) * time.Second)

	var wg sync.WaitGroup
	sem := make(chan struct{}, fetchConcurrency)
	var mu sync.Mutex
	totalNew := 0

	for _, src := range sources {
		if src.FeedURL == "" {
			fmt.Printf("Skipping %s (no feed URL)\n", src.Name)
			continue
		}

		wg.Add(1)
		go func(s source.Source) {
			defer wg.Done()
			sem <- struct{}{}
			defer func() { <-sem }()

			fmt.Printf("Fetching %s...\n", s.Name)

			posts, err := fetcher.FetchFeed(s.FeedURL)
			if err != nil {
				fmt.Printf("  Error: %v\n", err)
				return
			}

			newCount := 0
			for _, p := range posts {
				exists, _ := postRepo.Exists(p.URL)
				if exists {
					continue
				}

				_, err := postRepo.Add(s.ID, p.URL, p.Title, p.Author, p.PublishedAt, p.Content)
				if err != nil {
					fmt.Printf("  Failed to save: %s\n", p.Title)
					continue
				}
				newCount++
			}

			srcRepo.UpdateLastFetched(s.ID)

			mu.Lock()
			totalNew += newCount
			mu.Unlock()

			fmt.Printf("  %s: %d new posts\n", s.Name, newCount)
		}(src)
	}

	wg.Wait()

	fmt.Printf("\nTotal: %d new posts fetched\n", totalNew)
	return nil
}
```

**Step 3: Build and test**

Run:
```bash
go build -o blogmon .
./blogmon fetch
```

Expected: Posts fetched from added sources

**Step 4: Commit**

```bash
git add .
git commit -m "feat: add fetch command with concurrent RSS fetching"
```

---

## Task 9: List Command

**Files:**
- Create: `cmd/list.go`

**Step 1: Implement list command**

```go
// cmd/list.go
package cmd

import (
	"fmt"
	"strings"
	"time"

	"github.com/charmbracelet/lipgloss"
	"github.com/julienpequegnot/blogmon/internal/config"
	"github.com/julienpequegnot/blogmon/internal/database"
	"github.com/julienpequegnot/blogmon/internal/post"
	"github.com/spf13/cobra"
)

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List posts",
	Long:  `List posts from monitored blogs, sorted by date.`,
	RunE:  runList,
}

var (
	listTop   int
	listSince string
)

func init() {
	rootCmd.AddCommand(listCmd)
	listCmd.Flags().IntVarP(&listTop, "top", "n", 20, "Number of posts to show")
	listCmd.Flags().StringVar(&listSince, "since", "", "Show posts since date (YYYY-MM-DD)")
}

func runList(cmd *cobra.Command, args []string) error {
	db, err := database.New(config.DBPath())
	if err != nil {
		return err
	}
	defer db.Close()

	repo := post.NewRepository(db)
	posts, err := repo.List(listTop, 0)
	if err != nil {
		return err
	}

	if len(posts) == 0 {
		fmt.Println("No posts found. Run 'blogmon fetch' to download posts.")
		return nil
	}

	// Styles
	headerStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("12"))
	idStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("8"))
	scoreStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("10"))
	dateStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("11"))
	sourceStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("14"))

	// Header
	fmt.Println(headerStyle.Render(fmt.Sprintf(" %-4s  %-5s  %-10s  %-20s  %s", "#", "SCORE", "DATE", "SOURCE", "TITLE")))
	fmt.Println(strings.Repeat("─", 100))

	for i, p := range posts {
		score := "-"
		if p.FinalScore != nil && *p.FinalScore > 0 {
			score = fmt.Sprintf("%.0f", *p.FinalScore)
		}

		date := "-"
		if p.PublishedAt != nil {
			date = p.PublishedAt.Format("2006-01-02")
		}

		sourceName := p.SourceName
		if len(sourceName) > 20 {
			sourceName = sourceName[:17] + "..."
		}

		title := p.Title
		if len(title) > 50 {
			title = title[:47] + "..."
		}

		fmt.Printf(" %s  %s  %s  %s  %s\n",
			idStyle.Render(fmt.Sprintf("%-4d", p.ID)),
			scoreStyle.Render(fmt.Sprintf("%-5s", score)),
			dateStyle.Render(fmt.Sprintf("%-10s", date)),
			sourceStyle.Render(fmt.Sprintf("%-20s", sourceName)),
			title,
		)

		if i >= listTop-1 {
			break
		}
	}

	return nil
}
```

**Step 2: Build and test**

Run:
```bash
go build -o blogmon .
./blogmon list
./blogmon list --top 5
```

Expected: Posts listed in table format

**Step 3: Commit**

```bash
git add .
git commit -m "feat: add list command with styled output"
```

---

## Task 10: Show Command

**Files:**
- Create: `cmd/show.go`

**Step 1: Implement show command**

```go
// cmd/show.go
package cmd

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/charmbracelet/lipgloss"
	"github.com/julienpequegnot/blogmon/internal/config"
	"github.com/julienpequegnot/blogmon/internal/database"
	"github.com/julienpequegnot/blogmon/internal/post"
	"github.com/spf13/cobra"
)

var showCmd = &cobra.Command{
	Use:   "show <post-id>",
	Short: "Show details of a post",
	Long:  `Display full details of a post including content and metadata.`,
	Args:  cobra.ExactArgs(1),
	RunE:  runShow,
}

func init() {
	rootCmd.AddCommand(showCmd)
}

func runShow(cmd *cobra.Command, args []string) error {
	id, err := strconv.ParseInt(args[0], 10, 64)
	if err != nil {
		return fmt.Errorf("invalid post ID: %s", args[0])
	}

	db, err := database.New(config.DBPath())
	if err != nil {
		return err
	}
	defer db.Close()

	repo := post.NewRepository(db)
	p, err := repo.Get(id)
	if err != nil {
		return fmt.Errorf("post not found: %d", id)
	}

	// Styles
	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("15"))
	labelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("8"))
	valueStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("7"))
	urlStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("12")).Underline(true)
	divider := lipgloss.NewStyle().Foreground(lipgloss.Color("8")).Render(strings.Repeat("━", 70))

	fmt.Println(divider)
	fmt.Println(titleStyle.Render(p.Title))
	fmt.Println(divider)

	fmt.Printf("%s %s\n", labelStyle.Render("Source:"), valueStyle.Render(p.SourceName))
	if p.Author != "" {
		fmt.Printf("%s %s\n", labelStyle.Render("Author:"), valueStyle.Render(p.Author))
	}
	if p.PublishedAt != nil {
		fmt.Printf("%s %s\n", labelStyle.Render("Published:"), valueStyle.Render(p.PublishedAt.Format("2006-01-02 15:04")))
	}
	if p.FinalScore != nil && *p.FinalScore > 0 {
		fmt.Printf("%s %.0f\n", labelStyle.Render("Score:"), *p.FinalScore)
	}
	fmt.Printf("%s %s\n", labelStyle.Render("URL:"), urlStyle.Render(p.URL))

	fmt.Println()

	// Show content preview (first 500 chars of clean content, or raw if no clean)
	content := p.ContentClean
	if content == "" {
		content = stripHTML(p.ContentRaw)
	}
	if len(content) > 500 {
		content = content[:500] + "..."
	}

	if content != "" {
		fmt.Println(labelStyle.Render("PREVIEW:"))
		fmt.Println(valueStyle.Render(content))
	}

	return nil
}

// Simple HTML tag stripper
func stripHTML(s string) string {
	var result strings.Builder
	inTag := false
	for _, r := range s {
		if r == '<' {
			inTag = true
		} else if r == '>' {
			inTag = false
		} else if !inTag {
			result.WriteRune(r)
		}
	}
	return strings.TrimSpace(result.String())
}
```

**Step 2: Build and test**

Run:
```bash
go build -o blogmon .
./blogmon show 1
```

Expected: Post details displayed

**Step 3: Commit**

```bash
git add .
git commit -m "feat: add show command"
```

---

## Task 11: Sources List Command

**Files:**
- Create: `cmd/sources.go`

**Step 1: Add sources list subcommand**

```go
// cmd/sources.go
package cmd

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/lipgloss"
	"github.com/julienpequegnot/blogmon/internal/config"
	"github.com/julienpequegnot/blogmon/internal/database"
	"github.com/julienpequegnot/blogmon/internal/source"
	"github.com/spf13/cobra"
)

var sourcesCmd = &cobra.Command{
	Use:   "sources",
	Short: "List monitored sources",
	Long:  `Display all blogs and RSS feeds being monitored.`,
	RunE:  runSources,
}

func init() {
	rootCmd.AddCommand(sourcesCmd)
}

func runSources(cmd *cobra.Command, args []string) error {
	db, err := database.New(config.DBPath())
	if err != nil {
		return err
	}
	defer db.Close()

	repo := source.NewRepository(db)
	sources, err := repo.List()
	if err != nil {
		return err
	}

	if len(sources) == 0 {
		fmt.Println("No sources configured. Add some with 'blogmon add <url>'")
		return nil
	}

	headerStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("12"))
	idStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("8"))
	nameStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("10"))
	urlStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("14"))

	fmt.Println(headerStyle.Render(fmt.Sprintf(" %-4s  %-25s  %s", "ID", "NAME", "URL")))
	fmt.Println(strings.Repeat("─", 80))

	for _, s := range sources {
		name := s.Name
		if len(name) > 25 {
			name = name[:22] + "..."
		}

		fmt.Printf(" %s  %s  %s\n",
			idStyle.Render(fmt.Sprintf("%-4d", s.ID)),
			nameStyle.Render(fmt.Sprintf("%-25s", name)),
			urlStyle.Render(s.URL),
		)
	}

	return nil
}
```

**Step 2: Build and test**

Run:
```bash
go build -o blogmon .
./blogmon sources
```

Expected: List of sources displayed

**Step 3: Commit**

```bash
git add .
git commit -m "feat: add sources list command"
```

---

## Task 12: Final Cleanup and Documentation

**Files:**
- Create: `README.md`
- Update: `cmd/root.go` (add version)

**Step 1: Add version flag**

```go
// Update cmd/root.go - add to init()
func init() {
	rootCmd.Version = "0.1.0"
}
```

**Step 2: Create README**

```markdown
# Blogmon

Monitor developer blogs, extract insights, and build a knowledge base.

## Installation

```bash
go install github.com/julienpequegnot/blogmon@latest
```

Or build from source:

```bash
git clone https://github.com/julienpequegnot/blogmon
cd blogmon
go build -o blogmon .
```

## Quick Start

```bash
# Initialize configuration and database
blogmon init

# Add blogs to monitor
blogmon add https://jvns.ca
blogmon add https://fasterthanli.me
blogmon add https://brooker.co.za

# Fetch posts
blogmon fetch

# List posts
blogmon list

# Show post details
blogmon show 1
```

## Commands

| Command | Description |
|---------|-------------|
| `blogmon init` | Initialize config and database |
| `blogmon add <url>` | Add a blog to monitor |
| `blogmon fetch` | Download new posts from feeds |
| `blogmon list` | List posts |
| `blogmon show <id>` | Show post details |
| `blogmon sources` | List monitored sources |

## Configuration

Config is stored in `~/.blogmon/config.yaml`

## Phase 1 MVP

This is the Phase 1 implementation. Future phases will add:
- LLM-powered insight extraction
- Community scoring (HN, Reddit)
- Concept graph and discovery
- Semantic search
```

**Step 3: Run all tests**

Run:
```bash
go test ./... -v
```

Expected: All tests pass

**Step 4: Build final binary**

Run:
```bash
go build -o blogmon .
./blogmon --version
```

Expected: `blogmon version 0.1.0`

**Step 5: Final commit**

```bash
git add .
git commit -m "docs: add README and version flag

Phase 1 MVP complete with:
- init, add, fetch, list, show, sources commands
- SQLite storage
- RSS feed discovery and fetching
- Styled terminal output"
```

---

## Summary

**Phase 1 MVP delivers:**
- Working CLI with 6 commands
- SQLite database with full schema
- RSS feed auto-discovery
- Concurrent feed fetching
- Styled terminal output

**Next: Phase 2 (Intelligence)**
- `extract` command with LLM integration
- `score` command with HN/Reddit APIs
- Keyword-based relevance scoring
